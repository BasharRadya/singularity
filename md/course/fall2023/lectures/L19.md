# Lecture 19 - 7 November 2023


## Topics Covered:
* P2 (lack of) questions
* Translating a user program into kernel code


### P2 (lack of) questions

We opened the floor for any and all questions about P2,
but we had no takers.
I hope everyone had fun with this one!
This is the first semester we are running this assignment.

We may unveil some of the mathematical structure
of this assignment later this week in L20.

###  Translating a user program into kernel code

We begin with a simple but non-trivial user program:

```c
$ cat user_code.c
#include <err.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct example
{
	char *message;
	size_t size;
};

static struct example *example_create(const char *msg)
{
	struct example *ex = malloc(sizeof *ex);
	if(!ex)
		goto out;
	ex->size = strlen(msg);
	ex->message = strdup(msg);
	if(!ex->message)
		goto out_free;
	return ex;
out_free:
	free(ex);
	ex = NULL;
out:
	return ex;
}

static void example_destroy(struct example *ex)
{
	free(ex->message);
	free(ex);
}

static bool example_update_message(struct example *ex, const char *msg)
{
	size_t size = strlen(msg);
	char *data = strdup(msg);
	if(!data)
		return false;
	free(ex->message);
	ex->message = data;
	ex->size = size;
	return true;
}

static char *example_get_message(struct example *ex)
{
	return ex->message;
}

int main(void)
{
	struct example *ex = example_create("hello");
	if(!ex)
		err(1, "unable to allocated ex");
	printf("%s\n", example_get_message(ex));
	if(!example_update_message(ex, "goodbye")) {
		int temperrno = errno;
		example_destroy(ex);
		errno = temperrno;
		err(1, "unable to update");
	}
	printf("%s\n", example_get_message(ex));
	example_destroy(ex);
	return 0;
}

```

Before we proceed, let's note a few key features.

**Data flow**

The program works with structured data, primarily in the form of `struct example`:

```c
struct example
{
	char *message;
	size_t size;
};
```

This pair of elements represent a simple byte string and its size.
Take note that both the data structure itself
and the memory located at `message`
can be allocated either statically or dynamically,
and we take care to ensure that these two layers are handled appropriately.

Our typical userspace entry point,
the `main` function,
declares a pointer to one of these `struct example` types
and then immediately assigns the return value of a constructor-style
function `example_create()`,
whose job is to encapsulate the finer details of allocation and initialization.

In good style, `main` is responsible for cleaning up it's own mess,
and this task is executed right before `main` returns back to the C library
at the bottom of the function by invocation of `example_destroy()`.
When implementing a more complex program, we may either pass a pointer to our
local reference in order to zero the value to avoid subsequent misuse by the caller,
i.e. a dangling pointer, however this is unnecessary complexity for this simple example
and it sufices to simply ensure that our program does not leak memory.
Usage of the userspace tool `valgrind` will validate this property of our program,
but we do admit for a short-lived program such as this example whose memory is cleaned up
by the kernel at termination, the fuss and rigor around memory leaks appears pedantic beyond
the practice of good habits. Though practice is reason enough,
we will soon find ourselves in kernelspace where there is no one to clean up after us.
In the kernel, a memory leak will persist until reboot and in the meantime will clog up
the functioning of the running
[memory allocator](https://lwn.net/Articles/229984/).


**Control Flow**

Our example program implements a control flow that should
not raise the eyebrows of a C programmer with beyond novice-level skill.
We don't do anything fancy with the entry point,
and we don't create any threads.
We invoke a constructor to allocate our memory in fairly standard form,
using the old reliable `malloc` function from the `<stdlib.h>` section
of the trusty C library. During instantiation, we make a couple of calls
to the `<string.h>` section in the form of `strlen()` and `strdup()`,
both of which assume as a precondition a nicely null-terminated input string
as the `msg` parameter. Likewise, we perform the same operations
in `example_update_message()`, assuming the same precondition.

Each of our calls to `malloc()` pairs with a corresponding call to `free()`,
both at the level of the allocated message and the data structure itself,
and in just the same pattern our `example_create` constructor function pairs
with our `example_destroy` destructor function. As you are no doubt already aware,
the `example_get_message()` implements a getter, while `example_update_message()`
implements a setter, the complexity of which is due to the need to duplicate the
byte-string `msg` argument and free the now-junk memory residing at the
address contained in `ex->message`.

**Error Flow**

A careful reader of our example may take alarm at a particular feature.
We too have heard these rumors, that the C `goto` statement is considered
["harmful"](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf).
Despite these tall tales, we inform you with confidence that while there
are many paths to correct code, the
[shortest path](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
to readability and maintainability is often by use of this fearsome little keyword.
For one, correct usage of `goto` and error case labeling as seen in our example
eliminates the need for repetitive code and and unnecessary indentation.
As it is
[written](https://www.kernel.org/doc/Documentation/process/coding-style.rst):
"if you need more than 3 levels of indentation, you're screwed anyway and you should fix your program".
No, we will not elaborate
[further](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1009.html).

Next, note our usage of `err()` from `<err.h>`.
This handy tool lets us perform the work of `perror()` and `exit`
with a single invocation.
We first pass the return code we would have handed to `exit`,
and then we specify the string snatched from the jaws of `perror()`.

The final point worth noting is our usage of `temperrno`.
Think of this as if we were "pushing" the value of `errno`
at that instance onto the stack,
like we would do at the assembly level for a register
before a jump or call into a section of code that may clobber said register.
The value of `errno` is set by the C library,
so usage of of the C library function `free()`
in our call to `example_destroy()` may overwrite the value of `errno` relevant
to that context for the purposes of our call to `err` just after we
"pop" the value of `errno` from our temporary stack variable.


**System Flow**

The program send the following text to `stdout` when run:

```
$ ./user_example 
hello
goodbye
```

Other than this, the program does not interact with the system
in any manner worth noting.

#### Leaving Kansas

Now that we have analyzed the user code with
excruciatingly thoroughly exposition,
let us turn to the primary task at hand.

In order to statisfy what we assume to be our reader's
ravenous appetites for kernel module code and aleviate
the all-to-familiar pangs of hunger for priviledged execution,
we'll begin by dropping the complete `diff -up` output between
the above program and its kernel equivalent:

```diff
$ diff -Naup user_code.c kernel_code.c
--- user_code.c	2023-11-07 23:30:25.792075105 -0500
+++ kernel_code.c	2023-11-07 23:30:16.628563819 -0500
@@ -1,9 +1,6 @@
-#include <err.h>
-#include <errno.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
 
 struct example
 {
@@ -13,16 +10,16 @@ struct example
 
 static struct example *example_create(const char *msg)
 {
-	struct example *ex = malloc(sizeof *ex);
+	struct example *ex = kmalloc(sizeof *ex, GFP_KERNEL);
 	if(!ex)
 		goto out;
 	ex->size = strlen(msg);
-	ex->message = strdup(msg);
+	ex->message = kstrdup(msg, GFP_KERNEL);
 	if(!ex->message)
 		goto out_free;
 	return ex;
 out_free:
-	free(ex);
+	kfree(ex);
 	ex = NULL;
 out:
 	return ex;
@@ -30,17 +27,17 @@ out:
 
 static void example_destroy(struct example *ex)
 {
-	free(ex->message);
-	free(ex);
+	kfree(ex->message);
+	kfree(ex);
 }
 
 static bool example_update_message(struct example *ex, const char *msg)
 {
 	size_t size = strlen(msg);
-	char *data = strdup(msg);
+	char *data = kstrdup(msg, GFP_KERNEL);
 	if(!data)
 		return false;
-	free(ex->message);
+	kfree(ex->message);
 	ex->message = data;
 	ex->size = size;
 	return true;
@@ -51,20 +48,39 @@ static char *example_get_message(struct
 	return ex->message;
 }
 
-int main(void)
+int example_init(void)
 {
+	int ret = -ENOMEM;
+	const char *msg;
 	struct example *ex = example_create("hello");
+	msg = KERN_ERR "unable to allocated ex";
 	if(!ex)
-		err(1, "unable to allocated ex");
-	printf("%s\n", example_get_message(ex));
-	if(!example_update_message(ex, "goodbye")) {
-		int temperrno = errno;
-		example_destroy(ex);
-		errno = temperrno;
-		err(1, "unable to update");
-	}
-	printf("%s\n", example_get_message(ex));
+		goto out;
+
+	pr_info("%s\n", example_get_message(ex));
+
+	msg = KERN_ERR "unable to update\n";
+	if(!example_update_message(ex, "goodbye"))
+		goto out_free;
+
+	pr_info("%s\n", example_get_message(ex));
+
+	ret = 0;
+	msg = NULL;
+out_free:
 	example_destroy(ex);
-	return 0;
+out:
+	if(msg)
+		printk(msg);
+	return ret;
+}
+
+void example_exit(void)
+{
 }
 
+module_init(example_init);
+module_exit(example_exit);
+
+MODULE_LICENSE("GPL");
+

```

The length of this `diff` output exceeds the length of the original user program.
We will proceed with an explanation of each chance.

#### Welcome to Oz

The transition to writing kernel code is a shift to another plane of reality.
Previous assumptions about what a C program looks like may no longer hold,
and the reader may encounter strange looking constructs and ludricrously
deep macro invocations, generating the sense of a feaver dream.
When all appears to be lost, bear in mind one key point:
There is no escape from the kernel.
The kernel has been running since the CPU exited the bootloader
and only a semi-magical illusion has hidden this raw truth from your eyes.
Today, we lift this curse from the reader,
revealing, as the scales fall from their eyes,
the vibrant glory of kernel module code,
and forever dispelling the last remnamant
of prestidigitation from their mental model of the computer.
Magic no more! The entirety of the machine,
software and hardware stack united as one,
lies bare before the attentive reader,
and nothing, save polynomial time factoring of large numbers,
remains beyond reach.

Well then, lets get started.


**Switch to kernel headers**

First off, the C library is not available
within the kernel, we discard the inclusion
of the header files the provide C library
declarations:

```
-#include <err.h>
-#include <errno.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
```

Instead, we include headers declaring
Linux kernel API entry points.
These paths are relative to the `include`
directory within the kernel repository.

The first,
[<linux/module.h>](https://elixir.bootlin.com/linux/latest/source/include/linux/module.h),
provides the basic building blocks for a kernel module,
such as `#define`s of the `module_init()` and `module_exit()` macros we encounter later on.
Importantly, this file also `#define`s the mandatory `MODULE_LICENSE()` macro,
which we will return to at the end, as well as `printk()` and the associated macros.
Next, we include
[<linux/string.h>](https://elixir.bootlin.com/linux/latest/source/include/linux/string.h)
to replace some of the functionality we accessed via the C library's `string.h`.
Some of the functions retain their familiar names, like `strlen()`, while others
like `kstrdup()` take on new names and new arguments.
Finally, in order to allocate and free memory, we include
[<linux/slab.h>](https://elixir.bootlin.com/linux/latest/source/include/linux/slab.h),
which gives us the duo of `kmalloc()` and `kfree()`,
second cousins of the familar userspace versions.

That's all for the `#include`s.
Here we can briefly note that the `struct example` we defined in userspace
is perfectly suitable for usage in kernelspace, so we skip right over it.
```
 struct example
 {
@@ -13,16 +10,16 @@ struct example
 
 static struct example *example_create(const char *msg)
 {
```

Now, we arrive at our first usage of `kmalloc()`.
Like userspace `malloc()`,
this function takes a number of bytes to allocate
as its first argument, but `kmalloc()` takes a mysterious
second argument. In fact, this is the same argument
passed as the mysterious second argument to `kstrdup()`.
Luckily for the simplicity of this paragraph, `kfree()`
works exactly like `free()`.

```
-	struct example *ex = malloc(sizeof *ex);
+	struct example *ex = kmalloc(sizeof *ex, GFP_KERNEL);
 	if(!ex)
 		goto out;
 	ex->size = strlen(msg);
-	ex->message = strdup(msg);
+	ex->message = kstrdup(msg, GFP_KERNEL);
 	if(!ex->message)
 		goto out_free;
 	return ex;
 out_free:
-	free(ex);
+	kfree(ex);
 	ex = NULL;
 out:
 	return ex;
@@ -30,17 +27,17 @@ out:
 
 static void example_destroy(struct example *ex)
 {
-	free(ex->message);
-	free(ex);
+	kfree(ex->message);
+	kfree(ex);
 }
 
 static bool example_update_message(struct example *ex, const char *msg)
 {
 	size_t size = strlen(msg);
-	char *data = strdup(msg);
+	char *data = kstrdup(msg, GFP_KERNEL);
 	if(!data)
 		return false;
-	free(ex->message);
+	kfree(ex->message);
 	ex->message = data;
 	ex->size = size;
 	return true;
@@ -51,20 +48,39 @@ static char *example_get_message(struct
 	return ex->message;
 }
```

The changes to the three functions `example_init()`,
`example_destroy()`, and `example_update_message()` are
all limited to these three substitutions, two of which introduce
this mysterious second `GFP_KERNEL` argument,
so we will pause here to discuss in more depth before getting into
the real funky stuff.

We find the declaration of kmalloc in the latter half of
[`include/linux/slab.h`](https://elixir.bootlin.com/linux/latest/source/include/linux/module.h),
and the included comment provides us with far more articulate explication than we could muster.

We include a snippet of the
[Linux `v6.6` kmalloc comment](https://elixir.bootlin.com/linux/v6.6/source/include/linux/slab.h#L548)
 verbatim:

```
 * The @flags argument may be one of the GFP flags defined at
 * include/linux/gfp_types.h and described at
 * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`
 *
 * The recommended usage of the @flags is described at
 * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`
 *
 * Below is a brief outline of the most useful GFP flags
 *
 * %GFP_KERNEL
 *	Allocate normal kernel ram. May sleep.
 *
 * %GFP_NOWAIT
 *	Allocation will not sleep.
 *
 * %GFP_ATOMIC
 *	Allocation will not sleep.  May use emergency pools.
 *
 * Also it is possible to set different flags by OR'ing
 * in one or more of the following additional @flags:
 *
 * %__GFP_ZERO
 *	Zero the allocated memory before returning. Also see kzalloc().
 *
 * %__GFP_HIGH
 *	This allocation has high priority and may use emergency pools.
 *
 * %__GFP_NOFAIL
 *	Indicate that this allocation is in no way allowed to fail
 *	(think twice before using).
 *
 * %__GFP_NORETRY
 *	If memory is not immediately available,
 *	then give up at once.
 *
 * %__GFP_NOWARN
 *	If allocation fails, don't issue any warnings.
 *
 * %__GFP_RETRY_MAYFAIL
 *	Try really hard to succeed the allocation but fail
 *	eventually.
```


The curious reader should feel free to pursue any rabit hole
referenced within that comment.

The signature of `kmalloc()` itself is quite simple when the funny business is hidden:

		void *kmalloc(size_t size, gfp_t flags)

The second argument is a `typedef`ed wrapper for what is really nothing more than a fancy
[`unsigned int`](https://elixir.bootlin.com/linux/v6.6/source/include/linux/types.h#L154),
but, in good style, these implementation details are hidden from unless we search for them.
Essentially, this second `flags` argument is used to specify additional options
to the memory allocator.
One could easily implement such a compact flags argument in userspace,
and certainly many of our readers have done so,
but we understand the confusion a novice kernel programmer may encounter
when forced to select options from a menu of foreign-language items in order
to perform a task as apparently simple as memory allocation.

Let us back up a couple of steps and motivate this complexity.
As we noted in our discussion of the userspace program in the "Data Flow" section,
there is no other process within a system who will come save the kernel.
Without expanding the scope of our analysis
[beyond a single system](https://en.wikipedia.org/wiki/Virtual_machine)
or into the realm of
[exotic hardware](https://en.wikipedia.org/wiki/Intel_Active_Management_Technology),
we must operate under the knowledge that kernel is the soverign and absolute monarch of a computer system
from the time that the bootloader kindly requests that the CPU to jump into the kernel code
to the time the computer is either reset or physically destroyed.
While this absolute authority grants the CPU the enjoyment of maximally privileged execution,
this absolute responsibility yolks the CPU with the burden of maximally privileged execution.

When we write kernel code, in this case a kernel module, that allocates and frees memory,
we can't just blindly type up some half-baked garbage willy-nilly
and grind out a compile/valgrind/debug loop until all the errors are ironed out.
Certainly
[there are tools](https://docs.kernel.org/dev-tools/kmemleak.html)
for searching the kernel for memory leaks,
but the instrumentation of the kernel is not nearly as trivial
as runtime instrumentation performed by `valgrind`.
To zoom into our particular context, take a closer look at the three `GFP_*` flags
in the `kmalloc()` comment which are not prefixed by a double underscore ("dunder"):

```
 * %GFP_KERNEL
 *	Allocate normal kernel ram. May sleep.
 *
 * %GFP_NOWAIT
 *	Allocation will not sleep.
 *
 * %GFP_ATOMIC
 *	Allocation will not sleep.  May use emergency pools.
```

We briefly note a
[(non-standards compliant)](https://stackoverflow.com/questions/73542215/leading-underscores-in-linux-kernel-programming)
design choice:
identifiers that begin with an underscore
are more "internal" than those without one,
and those with two are are extra internal.
While internal is doing a lot of heavy lifting
in that sentence, the context of each usage clarifies the details.
A less "internal" API function may be
[exported as a symbol](https://docs.kernel.org/core-api/symbol-namespaces.html)
to the rest of the kernel,
while a more "internal" identifier may provide an entry point
to a kernel function that skips certain locking steps,
or in case of
[`_copy_from_user()`](https://elixir.bootlin.com/linux/v6.6/source/include/linux/uaccess.h#L143),
[permissions and protection checks](https://unix.stackexchange.com/questions/674962/why-are-copy-from-user-and-copy-to-user-needed-when-the-kernel-is-mappe).
In the case of the `GFP_*` flags above,
the dunder versions are declared as such
to hint to kernel engineers that these flags
are generally not used directly like the non-dunder versions.

As can be validated by a `ctrl+f`,
our kernel module uses `GFP_KERNEL`.
This is because we are running in the context of
a user process and therefore it's ok if the
codepath of the allocation includes a sleep or two
before returning to the caller.
We may even schedule out and switch processes multiple times
before the allocation spits out the needed valid memory address.
However, the CPU may be executing code in a context
where sleep is not only undesirable,
but theoretically terminal for the entire system.
One example of such a context is within the
[top-half or bottom-half](https://static.lwn.net/images/pdf/LDD3/ch10.pdf#page=18)
of an interupt handler.

The crucial topic of kernel context
deserves its own thorough treatment,
so we will only briefly touch upon it here.
The essential difference for our purpose
is that kernel code can sleep in user context,
while it cannot sleep in atomic or interupt context.
In process context, we have a process assocsiated with
the running kernel thread, though the immediate business
of the kernel may not be directly relevant to that particular
userspace process.
These kernel threads can copy data to or from userspace memory,
send signals to the current process,
and generally muck around with the
[`struct task_struct`](https://elixir.bootlin.com/linux/v6.6/source/include/linux/sched.h#L743)
found by dereferencing the address the `current` macro resolves to.
On the other hand,
a kernel thread running in interupt or atomic context
doesn't have any userspace process associated with itself.
Though `current` will point to the process whose execution
this kernel thread is interupting,
this thread must acomplish its business as soon as possible.
It cannot sleep at all,
so any memory allocation must return immediately.
The `GFP_NOWAIT` flag requests this behavior with less urgency,
however the `GFP_ATOMIC` flag send the allocation request with
a huge, red, bold exclamation mark attatched,
and requests to be fed with the emergency reserves in the case of low memory.
This is sane, as we would like something like our keyboard to be able to
send interupts that are immediately recieved and processed,
even when the bloated closed-source
software we run by choice or by force decides to consume all of our system resources.

tl;dr just use `GFP_KERNEL` unless you have a good reason not to.


At last, we move on to the changes to our classical userspace entry point.

```
-int main(void)
+int example_init(void)
```

This change simply renames `main` to `example_init`.
Do not take this for magic, this is nothing but convention.
We would just as well call our module initialization function `main`,
but this would be confusing.

```
 {
+	int ret = -ENOMEM;
```

We declare this return code

```
+	const char *msg;
 	struct example *ex = example_create("hello");
+	msg = KERN_ERR "unable to allocated ex";
 	if(!ex)
-		err(1, "unable to allocated ex");
-	printf("%s\n", example_get_message(ex));
-	if(!example_update_message(ex, "goodbye")) {
-		int temperrno = errno;
-		example_destroy(ex);
-		errno = temperrno;
-		err(1, "unable to update");
-	}
-	printf("%s\n", example_get_message(ex));
+		goto out;
+
+	pr_info("%s\n", example_get_message(ex));
+
+	msg = KERN_ERR "unable to update\n";
+	if(!example_update_message(ex, "goodbye"))
+		goto out_free;
+
+	pr_info("%s\n", example_get_message(ex));
+
+	ret = 0;
+	msg = NULL;
+out_free:
 	example_destroy(ex);
-	return 0;
+out:
+	if(msg)
+		printk(msg);
+	return ret;
+}
```


```
+void example_exit(void)
+{
 }



```
+module_init(example_init);
+module_exit(example_exit);


```
+MODULE_LICENSE("GPL");

```
Finally, we come to the enigmatic legalese
that the kernel build system simply cannot do without.



