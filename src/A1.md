### A1 - Build a Shell üêö

The objective of this assignment is to build a UNIX style shell.

#### Outcomes:
* Demonstrate your knowledge of C, specifically working with strings.
* Get an introduction to system calls.
* Make sure the course is a good fit for you.

#### Procedure:
* This assignment will guide you through the process of building a shell by iteratively improving your code and adding more features, starting with a very simple program. At the end you should have a shell that mostly works.
* You must make at least one commit per tier passed, and label clearly at which commit you think you completed a particular level.
* You are required to pass level 5. You are welcome to go further, see level 6+ for details...

#### Levels:
* lvl 0: 
  * Get the shell to spit out a prompt, informing the user about which absolute path they are currently on (using getcwd followed by a $ and a space).
  * The shell then prints a new line and exits without any user interaction.
* lvl 1:
  * The shell should take in any input at this stage, but doesn't need to do anything with it. It will simply print a new prompt if text is sent to stdin.
  * Loops until EOF from user input (ctl+d).
* lvl 2:
  * Print "Unrecognized command" if the user enters any text, but do not exit the shell.
  * However, if the user just hits enter without typing anything, there shouldn't be any error message.
* lvl 3:
  * Reads the line of input, splits it into pieces delimited by whitespace characters (see `man 3 isspace`).
  * Instead of just printing "Unrecognized commmand" it shall include the name of the program (e.g. if the user types `cat shell.c`, the shell prints "Unrecognized commmand: cat").
* lvl 4:
  * the shell will support a few builtin commands (exit, cd and exec). If the first piece of the input is not "exit" or "cd" or "exec" it will still print the unrecognized command message, otherwise:
    * exit: takes no arguments (should print error if they are provided) and closes the shell (return value of 0)
    * cd: should take exactly one argument (otherwise it prints usage info) and changes the working directory of shell process (see `man 2 chdir`). If chdir does not accept the path provided, an error message with the description of the errno returned should be printed. The new directory will appear in the prompt.
    * exec: takes at least one argument (maybe more) and replaces the shell with an instance of the command specified using the execv function. If execv fails, an error message should be printed explaining the errno returned.
* lvl 5:
  * The shell will be able to run executable files as commands within child processes. If the first piece of the input looks like a path (starts with . or /) a child process should be created (see `man 2 fork`) and the command specified by the first argument should be executed within the child using the provided arguments (see `man 3 execv`) similar to the exec builtin, otherwise the child process should print and error message with execv's errno describing the issue (don't forget to exit the child process). The shell should wait for the child to finish running before printing the next prompt (see `man 2 waitpid`).
le
* lvl 6:
  * In the case that the user types something that isn't a path or a builtin, before printing the unrecognized command error, the shell should check whether a file with that name exists in each of the directories listed in the `PATH` environment variable in order (see `man 3 getenv` and `man 2 stat`). If a file, with that name is found, the search can stop and that file can be executed. Only if no file is found in any of the directories, should the unrecognized command error be printed (NOTE: you must do the path searching manually, and cannot rely on a member of the exec family that does path searching automatically e.g. `execvp`).
* lvl 7:
  * Before processing the entered commands, the shell should do home directory substitution on pieces (comman name or arguments) that start with a `~`.
  * See the following requirements:
    * The shell should determine a username string, by taking a substring from after the `~` until the end of the string or the first `/`, whichever comes first.
    * If the username string is empty, then the `~` should be replaced with the value of the `HOME` environment variable.
    * If the username string is not empty, the shell should attempt to locate the the user with that name and replace the `~` and the username substring with their home directory (see `man 3 getpwnam`).
    * If `getpwnam` does not locate such user, the shell should leave the string unmodified.
* lvl 8:
  * As the shell is processing the commands and arguments is it finds a `<` or `>`, it should skip any whitespace characters, if any, and attempt to treat the next string as a filename for redirection (see `man 2 dup` and `man 2 dup2`). If there are multiple same redirections, then the right-most one takes precedence.
* lvl 9:
  * The shell needs to take the `|` operator and redirect the output from the left hand operand to the right hand operand (see `man 2 pipe` or `man 2 pipe2` üëÄ). The shell should be able to handle more than one pipe. Any file redirections should take precedence over the implied redirections of the pipe.
