# Lecture 7 - 3 October 2023

## Topics covered:

* Basics of kernelspace
* Tracing with ftrace
* Syscalls in kernel source
* Tracing with bpftrace

### Basics of kernelspace

To begin, we used parts of the [Kernel Modules and Device Drivers](https://kdlp.underground.software/course/slides/modules_drivers.html) slide deck.

* The slides are a little bit out of sync with how we have re-arranged the course and we have not yet reached device driver development.

* The last three slides were the most relevant, however students may be interested in taking a look at the rest of it.

* The kernel uses a small, fixed-size stack, compared to the larger, extendable stack used by userspace programs.

* The C library, itself being a userspace program, is not available in kernelspace. Instead, many -- but importantly not all -- are implemented within the kernel.

* For example, the IEEE754 floating point storage type that we all know and love from userspace C programming is entirely banned from the kernel.

* The reason is that when CPU switches between kernelspace and userspace, it has to save and restore it's executionn state to remember where it left off, and saving and restoring the floating point registers is considered to be too much overhead.

* The kernel uses a different range of the address space than userspace. On x86_64 systems, the virtual address space is generally split in half

#### The most important takeaway: kernel code is **reentrant**

* <u>Definition</u>: A computer program is considered **reentrant** if and only if multiple concurrent executions of the same program always run correctly.

* Further information can be found on the [reentrancy](https://en.wikipedia.org/wiki/Reentrancy_(computing)) Wikipedia page.

* Assume that *any* line of code in the kernel can be running at *any* time with *any* number of concurrent executions of the same code.

### Tracing with ftrace

Ftrace is mounted as tracefs file system, usually at `/sys/kernel/debug/tracing`

The kernel source has some
[documentation](https://www.kernel.org/doc/Documentation/trace/ftrace.txt)

The demon in class was done approximately like so:

0. Ensure tracing is off and wipe the buffer:

		echo -n > trace
		echo 0 > tracing_on

0. Select the function_graph  tracer instead of nop tracer
		echo function_graph > current_tracer

0. Turn tracing on and back off again

		echo 1 > tracing_on
		echo 0 > tracing_on

0. Take a look at the output

		{one of: less,nano,vim} trace

The events recorded in this file all took place between enable and disabling tracing. There should be a large number of lines in this file.

### Syscalls in kernel source

Definition of SYSCALL_DEFINE\* macros

[/include/linux/syscalls.h](https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h)

This will quickly locate the syscall named `$SYSCALLNAME` in the kernel:

	git grep '^SYSCALL_DEFINE.($SYSCALLNAME'

e.g: `^SYSCALL_DEFINE.(read'`

### Tracing with bpftrace

[Great Reference Guide](https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md)

[The BPF Bible: how to become one with the kernel](https://www.amazon.com/Performance-Tools-Addison-Wesley-Professional-Computing/dp/0136554822)

The syntax based on awk, which is based on C

**Usage examples:**

List all available kprobes that trace functions containing the characters xxx:
		bpftrace -l k:*xxx*

`bpftrace -e 'k:xxx { printf("%s/%d\n", comm, pid) ; }'`

**Cscope Interlude**

With the vim cscope plugin and cscope installed on your system:

Run: `cscope -R -k` in the root of your kernel tree to create your cscope database.


Within vim you can use `cs find g struct cs find t 'struct whatever {'` to find the definition of that structure. You can also do this without vim by directly running `cscope` in your kernel tree.


**Concluding Demo**

First, we'll need a little program to trace:

```
[root@kdlp ~]# cat > foo <<EOF
#!/bin/bash

echo x > x
cat x
EOF
[root@kdlp bpftest]# chmod +x foo

```

Trigger on the read system call and print it's arguments (sans user buffer), the kernel stack, and the userspace stack.

	bpftrace -e  'kprobe:__x64_sys_read /comm=="foo"/ { printf("hello read(%d, %s, %zu) %s/%d [%s] [%s]\n",arg0, str(arg1), arg2, comm, pid, kstack, ustack); }'

This is unwieldy at the interactive shell. Let's put it in an executable file with some formatting:

```
[root@kdlp bpftest]# cat > kprobe_read.bp <<EOF
#!/bin/env bpftrace

kprobe:__x64_sys_read /comm=="foo"/
{
        printf("hello read(%d, %s, %zu) %s/%d [%s] [%s]\n",
                arg0, str(arg1), arg2, comm, pid, kstack, ustack);
}
EOF
[root@kdlp bpftest]# chmod +x kprobe_read.bp
[root@kdlp bpftest]# ./kprobe_read.bp
Attaching 1 probe...
....
```

Alternatively, we can use a tracepoint and directly access all of the arguments by name, including the buf argument:

```
[root@kdlp bpftest]# cat > tracepoint_read.bp <<EOF
#!/bin/env bpftrace

tracepoint:syscalls:sys_enter_read /comm=="foo"/
{
        printf("hello read(%d, %s, %zu) %s/%d [%s] [%s]\n",
                args->fd, str(args->buf), args->count, comm, pid, kstack, ustack);
}
EOF

[root@kdlp bpftest]# chmod +x tracepoint_read.bp
[root@kdlp bpftest]# ./tracepoint_read.bp
Attaching 1 probe...
```

### Important Reminders

Final submission for [E1](https://kdlp.underground.software/course/fall2023/assignments/E1.md) is due Thursday 5 October 2023 by 11:59 PM
